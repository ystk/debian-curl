The following sequence of patches is based on these upstream commits:
https://github.com/curl/curl/commit/08b8ef4e726ba10f45081ecda5b3cea788d3c839
https://github.com/curl/curl/commit/620ea21410030a9977396b4661806bc187231b79
https://github.com/curl/curl/commit/5295e8d64ac6949ecb3f9e564317a608f51b90d8
https://github.com/curl/curl/commit/139a54ed0a172adaaf1a78d6f4fff50b2c3f9e08

It is further based on work by Kamil Dudka <kdudka@redhat.com> for
CentOS 8 and CentOS 9:
https://gitlab.com/redhat/centos-stream/rpms/curl/-/blob/c9s/0013-curl-7.76.1-CVE-2022-27774.patch
https://gitlab.com/redhat/centos-stream/rpms/curl/-/blob/c8s/0038-curl-7.61.1-CVE-2022-27774.patch


From 6307fa6f9784402ba58697f46ba04354225391b7 Mon Sep 17 00:00:00 2001
From: Daniel Stenberg <daniel@haxx.se>
Date: Mon, 25 Apr 2022 16:24:33 +0200
Subject: [PATCH 2/4] transfer: redirects to other protocols or ports clear
 auth

... unless explicitly permitted.

Bug: https://curl.se/docs/CVE-2022-27774.html
Reported-by: Harry Sintonen
Closes #8748

Upstream-commit: 620ea21410030a9977396b4661806bc187231b79
Signed-off-by: Kamil Dudka <kdudka@redhat.com>
---
 lib/transfer.c |   63 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 lib/url.c      |   27 +++++++++++++++---------
 lib/urldata.h  |    1 
 3 files changed, 81 insertions(+), 10 deletions(-)

--- a/lib/transfer.c
+++ b/lib/transfer.c
@@ -1299,6 +1299,7 @@
 
   data->set.followlocation=0; /* reset the location-follow counter */
   data->state.this_is_a_follow = FALSE; /* reset this */
+  data->state.this_is_a_follow_without_auth = FALSE;
   data->state.errorbuf = FALSE; /* no error has occurred */
   data->state.httpversion = 0; /* don't assume any particular server version */
 
@@ -1704,6 +1705,68 @@
 
   }
 
+  /* Clear auth if this redirects to a different port number or protocol,
+     unless permitted */
+  if(!data->set.allow_auth_to_other_hosts && (type != FOLLOW_FAKE)) {
+    int port;
+    bool clear = FALSE;
+
+    CURLU *u = curl_url();
+    if(!u)
+      return CURLE_OUT_OF_MEMORY;
+
+    uc = curl_url_set(u, CURLUPART_URL, newurl,
+        ((type == FOLLOW_REDIR) ? CURLU_URLENCODE : 0));
+    if(uc) {
+      infof(data, "Clear auth, curl_url_set() failed\n");
+      clear = TRUE;
+    }
+
+    if(!clear) {
+      if(data->set.use_port && data->state.allow_port)
+        /* a custom port is used */
+        port = (int)data->set.use_port;
+      else {
+        char *portnum;
+        uc = curl_url_get(u, CURLUPART_PORT, &portnum, CURLU_DEFAULT_PORT);
+        if(uc) {
+          infof(data, "Clear auth, failed to parse port number\n");
+          clear = TRUE;
+        }
+        else {
+          port = atoi(portnum);
+          free(portnum);
+        }
+      }
+    }
+    if(!clear && port != data->info.conn_remote_port) {
+      infof(data, "Clear auth, redirects to port from %u to %u\n",
+            data->info.conn_remote_port, port);
+      clear = TRUE;
+    }
+    if(!clear) {
+      char *scheme;
+      const struct Curl_handler *p;
+      uc = curl_url_get(u, CURLUPART_SCHEME, &scheme, 0);
+      if(uc) {
+        infof(data, "Clear auth, failed to parse scheme\n");
+        clear = TRUE;
+      }
+      else {
+        p = Curl_builtin_scheme(scheme);
+        if(p && (p->protocol != data->easy_conn->handler->protocol)) {
+          infof(data, "Clear auth, redirects scheme from %s to %s\n",
+                data->easy_conn->handler->scheme, scheme);
+          clear = TRUE;
+        }
+        free(scheme);
+      }
+    }
+    if(clear)
+      data->state.this_is_a_follow_without_auth = TRUE;
+    curl_url_cleanup(u);
+  }
+
   if(type == FOLLOW_FAKE) {
     /* we're only figuring out the new url if we would've followed locations
        but now we're done so we can get out! */
--- a/lib/url.c
+++ b/lib/url.c
@@ -4953,18 +4953,25 @@
                                struct connectdata *conn,
                                char **userp, char **passwdp, char **optionsp)
 {
-  if(data->set.str[STRING_USERNAME]) {
-    free(*userp);
-    *userp = strdup(data->set.str[STRING_USERNAME]);
-    if(!*userp)
-      return CURLE_OUT_OF_MEMORY;
+  if(data->state.this_is_a_follow
+      && data->state.this_is_a_follow_without_auth)
+  {
+    conn->bits.user_passwd = FALSE;
   }
+  else {
+    if(data->set.str[STRING_USERNAME]) {
+      free(*userp);
+      *userp = strdup(data->set.str[STRING_USERNAME]);
+      if(!*userp)
+        return CURLE_OUT_OF_MEMORY;
+    }
 
-  if(data->set.str[STRING_PASSWORD]) {
-    free(*passwdp);
-    *passwdp = strdup(data->set.str[STRING_PASSWORD]);
-    if(!*passwdp)
-      return CURLE_OUT_OF_MEMORY;
+    if(data->set.str[STRING_PASSWORD]) {
+      free(*passwdp);
+      *passwdp = strdup(data->set.str[STRING_PASSWORD]);
+      if(!*passwdp)
+        return CURLE_OUT_OF_MEMORY;
+    }
   }
 
   if(data->set.str[STRING_OPTIONS]) {
--- a/lib/urldata.h
+++ b/lib/urldata.h
@@ -1244,6 +1244,7 @@
   curl_off_t current_speed;  /* the ProgressShow() funcion sets this,
                                 bytes / second */
   bool this_is_a_follow; /* this is a followed Location: request */
+  bool this_is_a_follow_without_auth;
 
   /* host name, port number and protocol of the first (not followed) request.
      if set, this should be the host name that we will sent authorization to,
