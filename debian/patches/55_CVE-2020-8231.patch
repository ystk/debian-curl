Index: curl-7.38.0/lib/connect.c
===================================================================
--- curl-7.38.0.orig/lib/connect.c	2020-09-21 16:09:19.749688232 +0200
+++ curl-7.38.0/lib/connect.c	2020-09-21 16:10:15.836375951 +0200
@@ -1154,15 +1154,15 @@
 }
 
 struct connfind {
-  struct connectdata *tofind;
-  bool found;
+  long id_tofind;
+  struct connectdata *found;
 };
 
 static int conn_is_conn(struct connectdata *conn, void *param)
 {
   struct connfind *f = (struct connfind *)param;
-  if(conn == f->tofind) {
-    f->found = TRUE;
+  if(conn->connection_id == f->id_tofind) {
+    f->found = conn;
     return 1;
   }
   return 0;
@@ -1183,22 +1183,25 @@
 
   /* this only works for an easy handle that has been used for
      curl_easy_perform()! */
-  if(data->state.lastconnect && data->multi_easy) {
-    struct connectdata *c = data->state.lastconnect;
+  if(data->state.lastconnect_id != -1 && data->multi_easy) {
+    struct connectdata *c;
     struct connfind find;
-    find.tofind = data->state.lastconnect;
-    find.found = FALSE;
+    find.id_tofind = data->state.lastconnect_id;
+    find.found = NULL;
 
     Curl_conncache_foreach(data->multi_easy->conn_cache, &find, conn_is_conn);
 
     if(!find.found) {
-      data->state.lastconnect = NULL;
+      data->state.lastconnect_id = -1;
       return CURL_SOCKET_BAD;
     }
 
-    if(connp)
+    c = find.found;
+    if(connp) {
       /* only store this if the caller cares for it */
       *connp = c;
+      c->data = data;
+    }
     sockfd = c->sock[FIRSTSOCKET];
     /* we have a socket connected, let's determine if the server shut down */
     /* determine if ssl */
Index: curl-7.38.0/lib/easy.c
===================================================================
--- curl-7.38.0.orig/lib/easy.c	2020-09-21 16:09:19.749688232 +0200
+++ curl-7.38.0/lib/easy.c	2020-09-21 16:09:19.745688041 +0200
@@ -895,8 +895,7 @@
 
   /* the connection cache is setup on demand */
   outcurl->state.conn_cache = NULL;
-
-  outcurl->state.lastconnect = NULL;
+  outcurl->state.lastconnect_id = -1;
 
   outcurl->progress.flags    = data->progress.flags;
   outcurl->progress.callback = data->progress.callback;
Index: curl-7.38.0/lib/multi.c
===================================================================
--- curl-7.38.0.orig/lib/multi.c	2020-09-21 16:09:19.749688232 +0200
+++ curl-7.38.0/lib/multi.c	2020-09-21 16:09:19.745688041 +0200
@@ -409,6 +409,7 @@
 
   /* Point to the multi's connection cache */
   data->state.conn_cache = multi->conn_cache;
+  data->state.lastconnect_id = -1;
 
   data->state.infilesize = data->set.filesize;
 
Index: curl-7.38.0/lib/url.c
===================================================================
--- curl-7.38.0.orig/lib/url.c	2020-09-21 16:09:19.749688232 +0200
+++ curl-7.38.0/lib/url.c	2020-09-21 16:09:19.745688041 +0200
@@ -640,7 +640,7 @@
     Curl_convert_init(data);
 
     /* most recent connection is not yet defined */
-    data->state.lastconnect = NULL;
+    data->state.lastconnect_id = -1;
 
     data->progress.flags |= PGRS_HIDE;
     data->state.current_speed = -1; /* init to negative == impossible */
@@ -5933,14 +5933,14 @@
     /* the connection is no longer in use */
     if(ConnectionDone(data, conn)) {
       /* remember the most recently used connection */
-      data->state.lastconnect = conn;
+      data->state.lastconnect_id = conn->connection_id;
 
       infof(data, "Connection #%ld to host %s left intact\n",
             conn->connection_id,
             conn->bits.httpproxy?conn->proxy.dispname:conn->host.dispname);
     }
     else
-      data->state.lastconnect = NULL;
+      data->state.lastconnect_id = -1;
   }
 
   *connp = NULL; /* to make the caller of this function better detect that
Index: curl-7.38.0/lib/urldata.h
===================================================================
--- curl-7.38.0.orig/lib/urldata.h	2020-09-21 16:09:19.749688232 +0200
+++ curl-7.38.0/lib/urldata.h	2020-09-21 16:09:19.745688041 +0200
@@ -1230,7 +1230,7 @@
   /* buffers to store authentication data in, as parsed from input options */
   struct timeval keeps_speed; /* for the progress meter really */
 
-  struct connectdata *lastconnect; /* The last connection, NULL if undefined */
+  long lastconnect_id; /* The last connection, -1 if undefined */
 
   char *headerbuff; /* allocated buffer to store headers in */
   size_t headersize;   /* size of the allocation */
