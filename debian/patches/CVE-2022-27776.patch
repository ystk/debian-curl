From: Markus Koschany <apo@debian.org>
Date: Wed, 17 Aug 2022 17:24:25 +0200
Subject: CVE-2022-27776

Origin: https://github.com/curl/curl/commit/6e659993952aa5f90f48864be84a1bbb047fc258
Bug-Debian: https://bugs.debian.org/1010252
---
 lib/http.c    | 36 ++++++++++++++++++++++++------------
 lib/urldata.h | 13 ++++++++-----
 2 files changed, 32 insertions(+), 17 deletions(-)

diff --git a/lib/http.c b/lib/http.c
index e3ec14b..c5a3daa 100644
--- a/lib/http.c
+++ b/lib/http.c
@@ -639,6 +639,21 @@ output_auth_headers(struct connectdata *conn,
   return CURLE_OK;
 }
 
+/*
+ * allow_auth_to_host() tells if autentication, cookies or other "sensitive
+ * data" can (still) be sent to this host.
+ */
+static bool allow_auth_to_host(struct SessionHandle *data)
+{
+  struct connectdata *conn = data->easy_conn;
+  return (!data->state.this_is_a_follow ||
+          data->set.allow_auth_to_other_hosts ||
+          (data->state.first_host &&
+           Curl_raw_equal(data->state.first_host, conn->host.name) &&
+           (data->state.first_remote_port == conn->remote_port) &&
+           (data->state.first_remote_protocol == conn->handler->protocol)));
+}
+
 /**
  * Curl_http_output_auth() setups the authentication headers for the
  * host/proxy and the correct authentication
@@ -707,15 +722,12 @@ Curl_http_output_auth(struct connectdata *conn,
        with it */
     authproxy->done = TRUE;
 
-  /* To prevent the user+password to get sent to other than the original
-     host due to a location-follow, we do some weirdo checks here */
-  if(!data->state.this_is_a_follow ||
-     conn->bits.netrc ||
-     !data->state.first_host ||
-     data->set.allow_auth_to_other_hosts ||
-     Curl_raw_equal(data->state.first_host, conn->host.name)) {
+  /* To prevent the user+password to get sent to other than the original host
+     due to a location-follow */
+  if(allow_auth_to_host(data)
+     || conn->bits.netrc
+    )
     result = output_auth_headers(conn, authhost, request, path, FALSE);
-  }
   else
     authhost->done = TRUE;
 
@@ -1624,10 +1636,7 @@ CURLcode Curl_add_custom_headers(struct connectdata *conn,
           else if(checkprefix("Authorization:", headers->data) &&
                   /* be careful of sending this potentially sensitive header to
                      other hosts */
-                  (data->state.this_is_a_follow &&
-                   data->state.first_host &&
-                   !data->set.allow_auth_to_other_hosts &&
-                   !Curl_raw_equal(data->state.first_host, conn->host.name)))
+                  !allow_auth_to_host(data))
             ;
           else {
             CURLcode result = Curl_add_bufferf(req_buffer, "%s\r\n",
@@ -1792,6 +1801,9 @@ CURLcode Curl_http(struct connectdata *conn, bool *done)
     data->state.first_host = strdup(conn->host.name);
     if(!data->state.first_host)
       return CURLE_OUT_OF_MEMORY;
+
+    data->state.first_remote_port = conn->remote_port;
+    data->state.first_remote_protocol = conn->handler->protocol;
   }
   http->writebytecount = http->readbytecount = 0;
 
diff --git a/lib/urldata.h b/lib/urldata.h
index e5f1e2b..96316ea 100644
--- a/lib/urldata.h
+++ b/lib/urldata.h
@@ -1241,11 +1241,14 @@ struct UrlState {
                                 bytes / second */
   bool this_is_a_follow; /* this is a followed Location: request */
 
-  char *first_host; /* if set, this should be the host name that we will
-                       sent authorization to, no else. Used to make Location:
-                       following not keep sending user+password... This is
-                       strdup() data.
-                    */
+  /* host name, port number and protocol of the first (not followed) request.
+     if set, this should be the host name that we will sent authorization to,
+     no else. Used to make Location: following not keep sending user+password.
+     This is strdup()ed data. */
+  char *first_host;
+  int first_remote_port;
+  unsigned int first_remote_protocol;
+
   struct curl_ssl_session *session; /* array of 'max_ssl_sessions' size */
   long sessionage;                  /* number of the most recent session */
   char *tempwrite;      /* allocated buffer to keep data in when a write
